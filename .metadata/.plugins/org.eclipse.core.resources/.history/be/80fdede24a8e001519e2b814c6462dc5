package all;

import java.util.*;

public class Problem6ExpressionWithBracket {
	public static void main(String[] args) {
		try {
			String expression = readExpression();
			// first parse the expression to tokens
			String[] tokens = expressionToTokens(expression);
			// second, transform it into reverse Polish notation
			String[] reversePolishNotation = shuntingYardAlgorithm(tokens);
			// finally, calculate it
			double result = calculateReversePolishNotation(reversePolishNotation);
			System.out.printf(expression + " = %.2f", result);
		} catch (ArithmeticException ex) {
			System.out.println("Division by zero.");
		} catch (NumberFormatException ex) {
			System.out.println("Invalid expression!");
		}
	}

	private static String[] shuntingYardAlgorithm(String[] tokens) {
		/*
		 * Modified pseudo-code from wikipedia
		 * 
		 * While there are tokens to be read: Read a token. If the token is a
		 * number, then add it to the output queue. If the token is an operator,
		 * o1, then: while there is an operator token, o2, at the top of the
		 * stack, and o1's precedence is less than or equal to that of o2, pop
		 * o2 off the stack, onto the output queue; push o1 onto the stack. If
		 * the token is a left parenthesis, then push it onto the stack. If the
		 * token is a right parenthesis: Until the token at the top of the stack
		 * is a left parenthesis, pop operators off the stack onto the output
		 * queue. Pop the left parenthesis from the stack, but not onto the
		 * output queue. When there are no more tokens to read: While there are
		 * still operator tokens in the stack: Pop the operator onto the output
		 * queue. Exit.
		 */
		Queue<String> output = new LinkedList<String>();
		Stack<String> operatorStack = new Stack<String>();
		Queue<String> queueTokens = new LinkedList<String>(tokens);

		while (queueTokens.Count > 0) {
			String token = queueTokens.Dequeue();
			if (IsTokenNumber(token)) {
				output.Enqueue(token);
			} else if (IsTokenOperator(token)) {
				while (operatorStack.Count > 0
						&& IsTokenOperator(operatorStack.Peek())
						&& GetOperatorPrecedence(token) <= GetOperatorPrecedence(operatorStack
								.Peek())) {
					output.Enqueue(operatorStack.Pop());
				}
				operatorStack.Push(token);
			} else if (token == "(") {
				operatorStack.Push(token);
			} else if (token == ")") {
				String poppedOperator = operatorStack.Pop();
				while (poppedOperator != "(") {
					output.Enqueue(poppedOperator);
					poppedOperator = operatorStack.Pop();

				}

			}
		}

		while (operatorStack.Count > 0) {
			output.Enqueue(operatorStack.Pop());
		}

		return output.ToArray();

	}
}
