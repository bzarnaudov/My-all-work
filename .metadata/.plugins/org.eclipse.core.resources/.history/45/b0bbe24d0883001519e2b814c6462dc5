package all;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Problem1Dijkstra {
	
	private static final int MAX_NUMBER_OF_NODES = 5010;
	
    private static PriorityQueue<Problem1Node> priorityQueue = new PriorityQueue<Problem1Node>();
    @SuppressWarnings("unchecked")
	private static List<Problem1Node>[] edges = new List[MAX_NUMBER_OF_NODES];
    private static int[] distance = new int[MAX_NUMBER_OF_NODES];
    private static int[] parents = new int[MAX_NUMBER_OF_NODES];
    private static HashMap<String, Integer> nodesStringToInt = new HashMap<String, Integer>();
    private static String[] nodesIntToString = new String[MAX_NUMBER_OF_NODES];
    private static int numberOfNodes = -1;
    private static Scanner inputLine;

	private static int isContained(String s) {
		if (!nodesStringToInt.containsKey(s)) {
			numberOfNodes++;
			edges[numberOfNodes] = new ArrayList<Problem1Node>();
			nodesStringToInt.put(s, numberOfNodes);
			nodesIntToString[numberOfNodes] = s;
			return numberOfNodes;
		} else {
			return nodesStringToInt.get(s);
		}
	}

	public static void readInput() {
        int x,y;
        Problem1Node current = new Problem1Node();
        inputLine = new Scanner(System.in);
        while (true) {
        	String input;
        	try {
        		input = inputLine.nextLine();
        	} catch (NoSuchElementException e) {
        		break;
        	}
        	if (input.equals("")) break;
            String[] inputs = input.split(" ");
            x = isContained(inputs[0]);
            y = isContained(inputs[1]);
            int lenght = Integer.parseInt(inputs[2]);
            current.setNum(y);
            current.setCos(lenght);
            edges[x].add(current);
            current.setNum(x);
            edges[y].add(current);
        }
    }

	private static void dijkstra(int start) {
        for (int i = 0; i < MAX_NUMBER_OF_NODES; i++) {
            distance[i] = Integer.MAX_VALUE;
        }
        Problem1Node current = new Problem1Node();
        for (int i = 0; i < edges[start].size(); i++) {
            distance[edges[start].get(i).getNum()] = edges[start].get(i).getCos();
            parents[edges[start].get(i).getNum()] = start;
            current.setNum(edges[start].get(i).getNum());
            current.setCos(edges[start].get(i).getCos());
            priorityQueue.add(current);
        }
        distance[start] = 0;
        parents[start] = 0;
        current.setNum(start);
        current.setCos(0);
        priorityQueue.add(current);
        while (priorityQueue.size() > 0) {
            current = priorityQueue.poll();
            if (current.getCos() <= distance[current.getNum()]) {
                for (int i = 0; i < edges[current.getNum()].size(); i++) {
                    if (distance[current.getNum()] + edges[current.getNum()].get(i).getCos() < distance[edges[current.getNum()].get(i).getNum()]) {
                        distance[edges[current.getNum()].get(i).getNum()] = distance[current.getNum()] + edges[current.getNum()].get(i).getCos();
                        parents[edges[current.getNum()].get(i).getNum()] = current.getNum();
                        Problem1Node newNodeInQueue = new Problem1Node();;
                        newNodeInQueue.setNum(edges[current.getNum()].get(i).getNum());
                        newNodeInQueue.setCos(distance[edges[current.getNum()].get(i).getNum()]);
                        priorityQueue.add(newNodeInQueue);
                    }
                }
            }
        }
    }

	private static void printPath(int vertex) {
        if (parents[vertex] != 0) {
            printPath(parents[vertex]);
        }
        System.out.print(nodesIntToString[vertex] + " ");
    }
	
	public static void findPaths() {
        int start, end;
        Scanner inputLine = new Scanner(System.in);
        while (true) {
        	String input;
        	try {
        		input = inputLine.nextLine();
        	} catch (NoSuchElementException e) {
        		break;
        	}
        	if (input.equals("")) break;
            String[] inputs = input.split(" ");
            start = isContained(inputs[0]);
            end = isContained(inputs[1]);
            dijkstra(start);
            if (distance[end] == Integer.MAX_VALUE) {
            	System.out.println("No path");
            } else {
            	System.out.print(distance[end] + " ");
                printPath(end);
                System.out.println();
            }
        }
        inputLine.close();
    }
	
}
