package pacman;

/**
 * The Ghost Class
 */
public class Ghost extends Movable{
	// Ghost states
	private String color;
	private String name;
	private Boolean isEatable;
//	private Vector direction;
	private int speed;

	/**
	 * Function – moves the Ghost
	 */
	public void move() {
		// Code that moves the ghost in the current direction
	}

	/**
	 * Function - change Ghost direction
	 */
	private void changeDirection() {
		// Code that changes the Ghost's direction
	}

	/**
	 * Function – change Ghost speed
	 */
	private void changeSpeed() {
		// Code that changes the Ghost's speed
	}

	/**
	 * Function – change Ghost color
	 */
	private void changeColor() {
		// Code that changes the Ghost's color
	}

	/**
	 * Function – change Ghost state
	 */
	public void changeState() {
		// Code that changes the Ghost's state
		// This function also will call the three functions of changeDirection,
		// changeSpeed, and changeColor
	}
	/**
	 * Getters and setters
	 */
	
	public static class Node {
		int y;
		int x;
		int l;
		Node parent;

		private Node(int y, int x, int l, Node parent) {
			this.y = y;
			this.x = x;
			this.l = l;
			this.parent = parent;
		}

		@Override
		public String toString() {
			return "" + y + " " + x + " " + l;
		}
	}
	
	public static Node bfs(int[][] maze, int startX, int startY, int wall) {
		Queue<Node> queue = new LinkedList<>();
		Node start = new Node(startY, startX, 0, null);
		queue.add(start);

		while (queue.peek() != null) {
			Node current = queue.remove();
			int y = current.y;
			int x = current.x;
			int l = current.l;

			if (y - 1 > -1 && maze[y - 1][x] != wall) {
				Node next = new Node(y - 1, x, l + 1, current);
				if (maze[y - 1][x] == 64) {
					return next;
				} else {
					maze[y - 1][x] = wall;
					queue.add(next);
				}
			}

			if (x - 1 > -1 && maze[y][x - 1] != wall) {
				Node next = new Node(y, x - 1, l + 1, current);
				if (maze[y][x - 1] == 64) {
					return next;
				} else {
					maze[y][x - 1] = wall;
					queue.add(next);
				}
			}

			if (x + 1 < 15 && maze[y][x + 1] != wall) {
				Node next = new Node(y, x + 1, l + 1, current);
				if (maze[y][x + 1] == 64) {
					return next;
				} else {
					maze[y][x + 1] = wall;
					queue.add(next);
				}
			}

			if (y + 1 < 15 && maze[y + 1][x] != wall) {
				Node next = new Node(y + 1, x, l + 1, current);
				if (maze[y + 1][x] == 64) {
					return next;
				} else {
					maze[y + 1][x] = wall;
					queue.add(next);
				}
			}
		}
		return null;
	}
}