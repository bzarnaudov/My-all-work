package all;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.PriorityQueue;

public class Problem1Dijkstra {
	
	private static final int MAX_NUMBER_OF_NODES = 5010;
	
    private static PriorityQueue<Problem1Node> priorityQueue = new PriorityQueue<Problem1Node>();
    private static ArrayList<Problem1Node>[] edges;
    private static int[] distance = new int[MAX_NUMBER_OF_NODES];
    private static int[] parents = new int[MAX_NUMBER_OF_NODES];
    private static HashMap<String, Integer> nodesStringToInt = new HashMap<String, Integer>();
    private static String[] nodesIntToString = new String[MAX_NUMBER_OF_NODES];
    private static int numberOfNodes=0;

	private static int IsContained(String s) {
		if (!nodesStringToInt.ContainsKey(s)) {
			numberOfNodes++;
			edges[numberOfNodes] = new List<node>();
			nodesStringToInt.Add(s, numberOfNodes);
			nodesIntToString[numberOfNodes] = s;
			return numberOfNodes;
		} else {
			return nodesStringToInt[s];
		}
	}

	static void readInput() {
        int x,y;
        node current;
        while (true) {
            string input = Console.ReadLine();
            if (input == "") break;
            string[] inputs = input.Split(' ');
            x = IsContained(inputs[0]);
            y = IsContained(inputs[1]);
            int lenght = int.Parse(inputs[2]);
            current.num = y;
            current.cos = lenght;
            edges[x].Add(current);
            current.num = x;
            edges[y].Add(current);
        }
    }

	static void Dijkstra(int start)
    {
        for (int i = 0; i < maxNumberOfNodes; i++)
        {
            distance[i] = int.MaxValue;
        }
        node current;
        for (int i = 0; i < edges[start].Count; i++)
        {
            distance[edges[start][i].num] = edges[start][i].cos;
            parents[edges[start][i].num] = start;
            current.num = edges[start][i].num;
            current.cos = edges[start][i].cos;
            priorityQueue.Add(current);
        }
        distance[start] = 0;
        parents[start] = 0;
        current.num = start;
        current.cos = 0;
        priorityQueue.Add(current);
        while (priorityQueue.Count > 0)
        {
            current = priorityQueue.First();
            priorityQueue.RemoveFirst();
            if (current.cos <= distance[current.num])
            {
                for (int i = 0; i < edges[current.num].Count; i++)
                {
                    if (distance[current.num] + edges[current.num][i].cos < distance[edges[current.num][i].num])
                    {
                        distance[edges[current.num][i].num] = distance[current.num] + edges[current.num][i].cos;
                        parents[edges[current.num][i].num] = current.num;
                        node newNodeInQueue;
                        newNodeInQueue.num = edges[current.num][i].num;
                        newNodeInQueue.cos = distance[edges[current.num][i].num];
                        priorityQueue.Add(newNodeInQueue);
                    }
                }
            }
        }
    }

	static void PrintPath(int vertex)
    {
        if (parents[vertex] != 0)
        {
            PrintPath(parents[vertex]);
        }
        Console.Write(nodesIntToString[vertex] + " ");
    }
	
	static void FindPaths()
    {
        int start, final;
        while (true)
        {
            string input = Console.ReadLine();
            if (input == "") break;
            string[] inputs = input.Split(' ');
            start = IsContained(inputs[0]);
            final = IsContained(inputs[1]);
            Dijkstra(start);
            if (distance[final] == int.MaxValue)
            {
                Console.WriteLine("No path!");
            }
            else
            {
                Console.Write(distance[final] + " ");
                PrintPath(final);
                Console.WriteLine();
            }
        }
    }
	
}
