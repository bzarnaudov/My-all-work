package stacksAndQueues;

import java.util.Iterator;
import java.util.NoSuchElementException;

import all.Problem7LinkedList.ListIterator;
@SuppressWarnings({"unchecked"})

public class Problem6LinkedStack<T> {
	
	private class Node{
		T element;
		Node next;
		
		Node(T element, Node nextNode) {
			this.element = element;
			this.next = nextNode;
		}
		Node(T element) {
			this.element = element;
			next = null;
		}
	}

	private Node firstNode;
	private int count;
	
	public Problem6LinkedStack() {
		this.firstNode = null;
		this.count = 0;
	}
	
	/**
	* Add element at the end of the list
	* @param item - the element you want to add
	*/
	
	public void push(T item) {
		if (this.firstNode == null) {
			// We have empty list
			this.firstNode = new Node(item);
		} else {
			// We have non-empty list
			Node newNode = new Node(item, this.firstNode);
			this.firstNode = newNode;
		}
		count++;
	}
	
	/**
	* @return the actual list length
	*/
	public int count() {
		return count;
	}
	
	/**
	* Removes and returns element on the specific index
	* @param index - the index of the element you want to remove
	* @return the removed element
	* @exception IndexOutOfBoundsException - when index is invalid
	*/
	public Object remove(int index) {
		if (index>=count || index<0) {
			throw new IndexOutOfBoundsException(
					"Invalid index: " + index);
		}
	
		// Find the element at the specified index
		int currentIndex = 0;
		Node currentNode = firstNode;
		Node prevNode = null;
		while (currentIndex < index) {
			prevNode = currentNode;
			currentNode = currentNode.next;
			currentIndex++;
		}
	
		// Remove the element
		count--;
		if (count==0) {
			firstNode = null;
			tail = null;
		} else if (prevNode == null) {
			firstNode = currentNode.next;
		} else {
			prevNode.next = currentNode.next;
		}
		return currentNode.element;
	}
	
	/**
	* Searches for given element in the list
	* @param item - the item you are searching for
	* @return the index of the last occurrence of
	* the element in the list or -1 when not found
	*/
	public int lastIndexOf(Object item) {
		int index = 0;
		int found = -1;
		Node current = firstNode;
		while (index < count) {
			if ((current.element!=null && current.element.equals(item))
					|| (current.element==null) && (item==null)) {
				found = index;
			}
			current = current.next;
			index++;
		}
		return found;
	}
	
	/**
	* Searches for given element in the list
	* @param item - the item you are searching for
	* @return the index of the first occurrence of
	* the element in the list or -1 when not found
	*/
	public int firstIndexOf(Object item) {
		int index = 0;
		Node current = firstNode;
		while (current != null) {
			if ((current.element!=null && current.element.equals(item))
					|| (current.element==null) && (item==null)) {
					return index;
			}
			current = current.next;
			index++;
		}
		return -1;
	}
	


	 @Override
	 public Iterator<Object> iterator() {
	     return new ListIterator();
	 }

	 public class ListIterator implements Iterator<Object> {
		 private Node currentNode;
		 private Node previous;

		 /**
		 * @param currentNode
		 */
		 public ListIterator() {
			 super();
			 this.currentNode = (Node) firstNode;
			 this.previous = null;
	     }

	     @Override
	     public boolean hasNext() {
	    	 if (currentNode != null && currentNode.next != null) {
	    		 return true;
	    	 } else {
	    		 return false;
	    	 }
	     }

	     @Override
	     public Object next() {
	    	 if (!hasNext()) {
	    		 throw new NoSuchElementException();
	    	 }
	    	 if ( previous == null ) {
	    		 previous = currentNode;
	    		 return previous.element;
	    	 }
	    	 currentNode = currentNode.next;
	    	 return currentNode.element;
	     }

	     @Override
	     public void remove() {
	    	 
	     }
	 }
}
