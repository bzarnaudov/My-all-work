package stacksAndQueues;

import java.util.Iterator;
import java.util.NoSuchvalueException;

import all.Problem7LinkedList.ListIterator;
@SuppressWarnings({"unchecked"})

public class Problem6LinkedStack<T> {
	
	private class Node<T>{
		T value;
		Node<T> nextNode;
		
		Node(T value, Node<T> nextNode) {
			this.value = value;
			this.nextNode = nextNode;
		}
		Node(T value) {
			this.value = value;
			this.nextNode = null;
		}
	}

	private Node<T> firstNode;
	private int count;
	
	public Problem6LinkedStack() {
		this.firstNode = null;
		this.count = 0;
	}
		
	public void push(T item) {
		if (this.firstNode == null) {
			// We have empty list
			this.firstNode = new Node<T>(item);
		} else {
			// We have non-empty list
			Node<T> newNode = new Node<T>(item, this.firstNode);
			this.firstNode = newNode;
		}
		count++;
	}
	
	public int count() {
		return count;
	}
	
	public T pop() {
        if (this.count == 0) {
              throw new NoSuchvalueException("Stack is empty");
        }
        this.count--;
        T poppedvalue = this.firstNode.value;
        this.firstNode = this.firstNode.next;
        return poppedvalue;
    }
	
	/**
	* Searches for given value in the list
	* @param item - the item you are searching for
	* @return the index of the last occurrence of
	* the value in the list or -1 when not found
	*/
	public int lastIndexOf(Object item) {
		int index = 0;
		int found = -1;
		Node current = firstNode;
		while (index < count) {
			if ((current.value!=null && current.value.equals(item))
					|| (current.value==null) && (item==null)) {
				found = index;
			}
			current = current.next;
			index++;
		}
		return found;
	}
	
	/**
	* Searches for given value in the list
	* @param item - the item you are searching for
	* @return the index of the first occurrence of
	* the value in the list or -1 when not found
	*/
	public int firstIndexOf(Object item) {
		int index = 0;
		Node current = firstNode;
		while (current != null) {
			if ((current.value!=null && current.value.equals(item))
					|| (current.value==null) && (item==null)) {
					return index;
			}
			current = current.next;
			index++;
		}
		return -1;
	}
	


	 @Override
	 public Iterator<Object> iterator() {
	     return new ListIterator();
	 }

	 public class ListIterator implements Iterator<Object> {
		 private Node currentNode;
		 private Node previous;

		 /**
		 * @param currentNode
		 */
		 public ListIterator() {
			 super();
			 this.currentNode = (Node) firstNode;
			 this.previous = null;
	     }

	     @Override
	     public boolean hasNext() {
	    	 if (currentNode != null && currentNode.next != null) {
	    		 return true;
	    	 } else {
	    		 return false;
	    	 }
	     }

	     @Override
	     public Object next() {
	    	 if (!hasNext()) {
	    		 throw new NoSuchvalueException();
	    	 }
	    	 if ( previous == null ) {
	    		 previous = currentNode;
	    		 return previous.value;
	    	 }
	    	 currentNode = currentNode.next;
	    	 return currentNode.value;
	     }

	     @Override
	     public void remove() {
	    	 
	     }
	 }
}
