package exercises;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

import exercises.Exercise14ParallelQuickSort.SortTask;

public class Exercise15ParallelSum {

	public static void main(String[] args) {
		final int SIZE = 9000000;
		double[] list = new double[SIZE];

		for (int i = 0; i < list.length; i++) {
			list[i] = Math.random() * 100;
//			if (i < 100) {
//				System.out.println(list[i]);
//			}
		}
		long startTime = System.currentTimeMillis();
		System.out.println(parallelSum(list)); // Invoke parallel merge sort
		long endTime = System.currentTimeMillis();
		System.out.println("\nParallel time with "
				+ Runtime.getRuntime().availableProcessors()
				+ " processors is " + (endTime - startTime) + " milliseconds");

		startTime = System.currentTimeMillis();
		System.out.println(sequentialSum(list));
		endTime = System.currentTimeMillis();
		System.out.println("\nSequential time is " + (endTime - startTime)
				+ " milliseconds");

	}

	private static double sequentialSum(double[] list) {
		double sum = 0;
		for (int i = 0; i < list.length; i++) {
			sum += list[i];
		}
		return sum;
	}

	private static double parallelSum(double[] list) {
		double sum= 0;
		int startIndex = 0;
		int endIndex = 0;
		RecursiveAction mainTask = new SumTask(list, startIndex, endIndex, sum);
		ForkJoinPool pool = new ForkJoinPool();
		pool.invoke(mainTask);
		return sum;
	}
	
	private static class SumTask extends RecursiveAction {
		private final int THRESHOLD = 500;
		private double[] list;
		private int startIndex, endIndex;
		double sum;
		
		SumTask(double[] list, int startIndex, int endIndex, double sum) {
			this.list = list;
			this.startIndex = startIndex;
			this.endIndex = endIndex;
			this.sum = sum;
		}
		
		@Override
		protected void compute() {
			// TODO Auto-generated method stub
			
		}
		
		
		
	}

}
