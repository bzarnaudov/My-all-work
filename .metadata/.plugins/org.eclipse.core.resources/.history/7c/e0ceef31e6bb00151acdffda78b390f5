package exercises;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

import all.ParallelMax.MaxTask;

public class Exercise15ParallelSum {

	public static void main(String[] args) {
		final int SIZE = 9000000;
		double[] list = new double[SIZE];

		for (int i = 0; i < list.length; i++) {
			list[i] = Math.random() * 100;
//			if (i < 100) {
//				System.out.println(list[i]);
//			}
		}
		long startTime = System.currentTimeMillis();
		System.out.println(parallelSum(list)); // Invoke parallel merge sort
		long endTime = System.currentTimeMillis();
		System.out.println("\nParallel time with "
				+ Runtime.getRuntime().availableProcessors()
				+ " processors is " + (endTime - startTime) + " milliseconds");

		startTime = System.currentTimeMillis();
		System.out.println(sequentialSum(list));
		endTime = System.currentTimeMillis();
		System.out.println("\nSequential time is " + (endTime - startTime)
				+ " milliseconds");

	}

	private static double sequentialSum(double[] list) {
		double sum = 0;
		for (int i = 0; i < list.length; i++) {
			sum += list[i];
		}
		return sum;
	}

	private static double parallelSum(double[] list) {

		RecursiveTask<Double> mainTask = new SumTask(list);
		ForkJoinPool pool = new ForkJoinPool();
		return pool.invoke(mainTask);
	}
	
	@SuppressWarnings("serial")
	private static class SumTask extends RecursiveTask<Double> {
		private final int THRESHOLD = 500;
		private double[] list;
		double sum;
		
		SumTask(double[] list) {
			this.list = list;
		}
		
		@Override
		protected Double compute() {
			double sum = 0;
			if (list.length < THRESHOLD) {
				sum = sequentialSum(list);
				return new Double(sum);
			} else {
				double[] firstHalf = new double[list.length / 2];
				System.arraycopy(list, 0, firstHalf, 0, list.length / 2);
				
				// Obtain the second half
				int secondHalfLength = list.length - list.length / 2;
				double[] secondHalf  = new double[secondHalfLength];
				System.arraycopy(list, list.length / 2, secondHalf, 0, secondHalfLength);
				
				
				RecursiveTask<Double> first = new SumTask(firstHalf);
				RecursiveTask<Double> second = new SumTask(secondHalf);
				first.fork();
				second.fork();
				return new Double(first.join().doubleValue() + second.join().doubleValue());
			}
		}
		
		
		
	}

}
