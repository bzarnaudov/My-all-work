package all;

import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.TreeSet;

public class Problem7GraphShortestPathbetweenVertices {

	public class Graph {
        private List<Edge> edges = new LinkedList<Edge>();

        public Graph() {  	
        }

        public void addEdge(char nodeOne, char nodeTwo) {
            edges.add(new Edge(nodeOne, nodeTwo));
        }

        public List<Edge> getEdges() {
			return edges;
		}

        public Graph createGraph() throws Exception {
            Graph graph = new Graph();
            Scanner input = new Scanner(System.in);
            String line = input.nextLine();

            while (line != "") {
                String[] edgeNodes = line.split(" ");
                if (edgeNodes.length > 2) {
                	input.close();
                    throw new Exception("Incorrect input: Graph edges can only have two nodes.");    
                }
                graph.addEdge(edgeNodes[0].charAt(0), edgeNodes[1].charAt(0));
                line = input.nextLine();
            }
            input.close();
            return graph;
        }
    }
	
    public class Edge {
        public char edgeNodeOne;
        public char edgeNodeTwo;
        public Integer cost = 0;
        
        public char getEdgeNodeOne() {
			return edgeNodeOne;
		}
		public void setEdgeNodeOne(char edgeNodeOne) {
			this.edgeNodeOne = edgeNodeOne;
		}
		public char getEdgeNodeTwo() {
			return edgeNodeTwo;
		}
		public void setEdgeNodeTwo(char edgeNodeTwo) {
			this.edgeNodeTwo = edgeNodeTwo;
		}
		

        public Edge(char nodeOne, char nodeTwo) {
            this.edgeNodeOne = nodeOne;
            this.edgeNodeTwo = nodeTwo;
        }
        public int compareTo(Edge otherEdge) {
            return this.cost.compareTo(otherEdge.cost);
        }
    }

    public static void BFS(Graph graph, char startNode, char goalNode) {
        List<Edge> edgesList = new LinkedList<Edge>();
        int cost = 1;
        TreeSet<Edge> openEdges = new TreeSet<Edge>();
        char currentNode = startNode;
        boolean[] visitedEdges = new boolean[graph.getEdges().size()];

        for (int index = 0; index < graph.Edges.Count; index++) {
            if ((graph.Edges[index].edgeNodeOne == currentNode) || (graph.Edges[index].edgeNodeTwo == currentNode))
            {
                Edge temp = graph.Edges[index];

                visitedEdges[index] = true;
                temp.cost = cost;
                openEdges.Add(temp);
            }
        }

        while (openEdges.Count != 0)
        {
            Edge currentEdge = openEdges.GetFirst();

            currentNode = currentEdge.edgeNodeOne;
            char nextNode = currentEdge.edgeNodeTwo;

            openEdges.RemoveFirst();

            if (currentEdge.edgeNodeOne == goalNode || currentEdge.edgeNodeTwo == goalNode)
            {
                Console.WriteLine(currentEdge.cost);
                return;
            }

            cost = currentEdge.cost + 1;

            for (int index = 0; index < graph.Edges.Count; index++)
            {
                if (!visitedEdges[index])
                {
                    if ((graph.Edges[index].edgeNodeOne == nextNode) || (graph.Edges[index].edgeNodeTwo == nextNode))
                    {
                        Edge temp = graph.Edges[index];

                        visitedEdges[index] = true;
                        temp.cost = cost;
                        openEdges.Add(temp);
                    }
                }
            }
        }
    }
    
    public static void main(String[] args) {
		Graph graph;
		BFS(graph, 'x','y');
	}

                        
                        
                        
                        
}
