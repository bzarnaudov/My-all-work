package exercises;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

import exercises.Exercise14ParallelQuickSort.SortTask;

public class Exercise15ParallelSum {

	public static void main(String[] args) {
		final int SIZE = 9000000;
		double[] list = new double[SIZE];

		for (int i = 0; i < list.length; i++) {
			list[i] = Math.random() * 100;
//			if (i < 100) {
//				System.out.println(list[i]);
//			}
		}
		long startTime = System.currentTimeMillis();
		System.out.println(parallelSum(list)); // Invoke parallel merge sort
		long endTime = System.currentTimeMillis();
		System.out.println("\nParallel time with "
				+ Runtime.getRuntime().availableProcessors()
				+ " processors is " + (endTime - startTime) + " milliseconds");

		startTime = System.currentTimeMillis();
		System.out.println(sequentialSum(list));
		endTime = System.currentTimeMillis();
		System.out.println("\nSequential time is " + (endTime - startTime)
				+ " milliseconds");

	}

	private static double sequentialSum(double[] list) {
		double sum = 0;
		for (int i = 0; i < list.length; i++) {
			sum += list[i];
		}
		return sum;
	}

	private static double parallelSum(double[] list) {
		RecursiveAction mainTask = new SumTask(list, 0, list.length - 1);
		ForkJoinPool pool = new ForkJoinPool();
		pool.invoke(mainTask);
		return 0;
	}

}
