package all;

public class Problem2LabirintAllPaths {
	static char[][] matrix;
    static Cell startCell = null;

    public class Cell {
        public int row;
        public int col;

        public int getRow() {
			return row;
		}

		public void setRow(int row) {
			this.row = row;
		}

		public int getCol() {
			return col;
		}

		public void setCol(int col) {
			this.col = col;
		}

		public Cell(int row, int col) {
            this.row = row;
            this.col = col;
        }
    }

    static void FindingAllPaths() {
        Queue<Cell> cellQueue = new Queue<Cell>();
        cellQueue.Enqueue(startCell);

        do
        {
            Cell currentCell = cellQueue.Dequeue();
            if (currentCell.Row + 1 < matrix.GetLength(0))
            {
                if (matrix[currentCell.Row + 1, currentCell.Col] == 'O')
                {
                    cellQueue.Enqueue(new Cell(
                        currentCell.Row + 1, currentCell.Col));
                    matrix[currentCell.Row + 1, currentCell.Col] = 'a';
                }
            }
            if (currentCell.Row - 1 >= 0)
            {
                if (matrix[currentCell.Row - 1, currentCell.Col] == 'O')
                {
                    cellQueue.Enqueue(
                        new Cell(currentCell.Row - 1, currentCell.Col));
                    matrix[currentCell.Row - 1, currentCell.Col] = 'a';
                }
            }
            if (currentCell.Col + 1 < matrix.GetLength(0))
            {
                if (matrix[currentCell.Row, currentCell.Col + 1] == 'O')
                {
                    cellQueue.Enqueue(
                        new Cell(currentCell.Row, currentCell.Col + 1));
                    matrix[currentCell.Row, currentCell.Col + 1] = 'a';
                }
            }
            if (currentCell.Col - 1 >= 0)
            {
                if(matrix[currentCell.Row,currentCell.Col-1] == 'O')
                {
                    cellQueue.Enqueue(
                        new Cell(currentCell.Row, currentCell.Col - 1));
                    matrix[currentCell.Row, currentCell.Col - 1] = 'a';
                }
            }
        } while (cellQueue.Count!=0);
    }

    static int FindExits()
    {
        int counterExits = 0;
        for (int i = 0; i < 1; i++)
        {
            for (int j = 0; i < matrix.GetLength(0); i++)
            {
                if (matrix[i, j] == 'a')
                {                     
                    counterExits++;
                    if (i == j) continue;
                }
                if (matrix[j, i] == 'a')
                {
                    counterExits++;
                }
            }
        }

        for (int i = matrix.GetLength(0) - 1; i > matrix.GetLength(0) - 2; i--)
        {
            for (int j = matrix.GetLength(0) - 1; i > 0; i--)
            {
                if (matrix[i, j] == 'a')
                {
                    counterExits++;
                    if (i == j) continue;
                }
                if (matrix[j, i] == 'a')
                {
                    counterExits++;
                }
            }
        }
        return counterExits;
    }

    static void Main(string[] args)
    {
        // Getting Cyrillic encoding 
        System.Text.Encoding encoding = System.Text.Encoding.GetEncoding(1251);

        StreamReader reader = new StreamReader(
            "../../Files/test.001.in.txt", encoding);
        int n = int.Parse(reader.ReadLine());
        matrix = new char[n, n];

        for (int i = 0; i < n; i++)
        {
            string line = reader.ReadLine();
            for (int j = 0; j < n; j++)
            {
                matrix[i, j] = line[j];
                if (line[j] == '*')
                {
                    startCell = new Cell(i, j);
                }
            }
        }
        reader.Close();

        FindingAllPaths();
        int numberOfExits = FindExits();

        StreamWriter writer = new StreamWriter(
            "../../Files/test.001.out.txt");
        using (writer)
        {
            writer.WriteLine(numberOfExits);
        }
    }

}
