package all;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Problem1Dijkstra {
	
	private static final int MAX_NUMBER_OF_NODES = 5010;
	
    private static PriorityQueue<Problem1Node> priorityQueue = new PriorityQueue<Problem1Node>();
    private static ArrayList<Problem1Node>[] edges;
    private static int[] distance = new int[MAX_NUMBER_OF_NODES];
    private static int[] parents = new int[MAX_NUMBER_OF_NODES];
    private static HashMap<String, Integer> nodesStringToInt = new HashMap<String, Integer>();
    private static String[] nodesIntToString = new String[MAX_NUMBER_OF_NODES];
    private static int numberOfNodes=0;

	private static int isContained(String s) {
		if (!nodesStringToInt.containsKey(s)) {
			numberOfNodes++;
			edges[numberOfNodes] = new ArrayList<Problem1Node>();
			nodesStringToInt.put(s, numberOfNodes);
			nodesIntToString[numberOfNodes] = s;
			return numberOfNodes;
		} else {
			return nodesStringToInt.get(s);
		}
	}

	public static void readInput() {
        int x,y;
        Problem1Node current = new Problem1Node();
        Scanner inputLine = new Scanner(System.in);
        while (true) {
            String input = inputLine.nextLine();
            if (input.equals("")) break;
            String[] inputs = input.split(" ");
            x = isContained(inputs[0]);
            y = isContained(inputs[1]);
            int lenght = Integer.parseInt(inputs[2]);
            current.setNum(y);
            current.setCos(lenght);
            edges[x].add(current);
            current.setNum(x);
            edges[y].add(current);
        }
        inputLine.close();
    }

	static void Dijkstra(int start)
    {
        for (int i = 0; i < maxNumberOfNodes; i++)
        {
            distance[i] = int.MaxValue;
        }
        node current;
        for (int i = 0; i < edges[start].Count; i++)
        {
            distance[edges[start][i].num] = edges[start][i].cos;
            parents[edges[start][i].num] = start;
            current.num = edges[start][i].num;
            current.cos = edges[start][i].cos;
            priorityQueue.Add(current);
        }
        distance[start] = 0;
        parents[start] = 0;
        current.num = start;
        current.cos = 0;
        priorityQueue.Add(current);
        while (priorityQueue.Count > 0)
        {
            current = priorityQueue.First();
            priorityQueue.RemoveFirst();
            if (current.cos <= distance[current.num])
            {
                for (int i = 0; i < edges[current.num].Count; i++)
                {
                    if (distance[current.num] + edges[current.num][i].cos < distance[edges[current.num][i].num])
                    {
                        distance[edges[current.num][i].num] = distance[current.num] + edges[current.num][i].cos;
                        parents[edges[current.num][i].num] = current.num;
                        node newNodeInQueue;
                        newNodeInQueue.num = edges[current.num][i].num;
                        newNodeInQueue.cos = distance[edges[current.num][i].num];
                        priorityQueue.Add(newNodeInQueue);
                    }
                }
            }
        }
    }

	static void PrintPath(int vertex)
    {
        if (parents[vertex] != 0)
        {
            PrintPath(parents[vertex]);
        }
        Console.Write(nodesIntToString[vertex] + " ");
    }
	
	public static void findPaths() {
        int start, end;
        Scanner inputLine = new Scanner(System.in);
        while (true) {
            String input = Console.ReadLine();
            if (input == "") break;
            string[] inputs = input.Split(' ');
            start = IsContained(inputs[0]);
            end = IsContained(inputs[1]);
            Dijkstra(start);
            if (distance[end] == int.MaxValue) {
                Console.WriteLine("No path!");
            }
            else {
                Console.Write(distance[end] + " ");
                PrintPath(end);
                Console.WriteLine();
            }
        }
        inputLine.close();
    }
	
}
