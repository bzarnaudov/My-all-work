package treesAndTreeLikeStructures;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Problem3CalculateArithmeticExpression {

	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		System.out.print("Please write arithmetic expression : ");
		String inputString = input.nextLine();
		String[] symbols = inputString.split(" ");

	}
	
	public static shuntingYardAlorithm(String[] symbols) {
		Queue<String> outputQueue = new LinkedList<String>();
		Stack<String> stack = new Stack<String>();
		for (int i=0; i< symbols.length; i++) {
			// 1. push numbers in output queue in any case
			if (isNumeric(symbols[i])) {
				outputQueue.add(symbols[i]);
			} else if (isFunction(symbols[i])) {
				// 2. Push operators in operation stack if stack is empty
				if (stack.isEmpty()) {
					stack.push(symbols[i]);
				} else {
					/* 
                     * 3. If operator to push is with higher precedence than 
                     * the top one - push it
                     * If not, pop all operators with higher or equal precedence 
                     * and push them to the queue 
                     */
					while (!stack.isEmpty() && isFunction(symbols[i]) && 
							isFunction(stack.peek()) && 
							(checkOperatorPrecedence(stack.peek(), symbols[i]) > 0)) {
						String topOperatorInStack = stack.pop();
						outputQueue.add(topOperatorInStack);
					}
					stack.push(symbols[i]);
				}
			} else if (symbols[i] == "(") {
				 // 4. If left parenthesis - push to stack
                stack.push(symbols[i]);
			} else if (symbols[i] == ")") {
				 /* 
                 * 5. If right parenthesis - 
                 * pop all operators from stack into queue
                 * until left parenthesis is reached 
                 */
                while (!stack.isEmpty() && stack.peek() != "(") {
                    String topOperatorInStack = stack.pop();
                    outputQueue.add(topOperatorInStack);
                }
                /* If no left parenthesis is reached - The expression is invalid */
                if (stack.isEmpty() || stack.peek() != "(") {
                    throw new Exception("The expression is invalid");
                } else {
                    stack.pop();
                }
			}
			
		}
	}
	
	public static int checkOperatorPrecedence (String first, String second) {
		if ((first == "-" || first == "+") &&
				(second == "*" || second == "/")) {
		        	return -1;
		        } else if ((second == "-" || second == "+") &&
		            (first == "*" || first == "/")) {
		        		return 1;
		        } else {
		        	return 0;
		        }
	}
	
	public static boolean isFunction(String str) {
		CharSequence cs1 = "^";
		CharSequence cs2 = "*";
		CharSequence cs3 = "/";
		CharSequence cs4 = "+";
		CharSequence cs5 = "-";
		
		return str.contains(cs1) || str.contains(cs2) ||
				str.contains(cs3) || str.contains(cs4) || 
				str.contains(cs5);
	}

	public static boolean isNumeric(String str) {
	  return str.matches("-?\\d+(\\.\\d+)?");  //match a number with optional '-' and decimal.
	}
	
	
}
