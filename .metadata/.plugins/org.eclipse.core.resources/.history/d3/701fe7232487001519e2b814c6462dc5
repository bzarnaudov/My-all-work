package all;

import java.io.File;
import java.util.*;

public class Problem2LabirintAllPaths {
	static char[][] matrix;
	static Problem2Cell startCell = null;

	public class Problem2Cell {
		private int row;
		private int col;

		public int getRow() {
			return row;
		}

		public void setRow(int row) {
			this.row = row;
		}

		public int getCol() {
			return col;
		}

		public void setCol(int col) {
			this.col = col;
		}

		public Problem2Cell(int row, int col) {
			this.row = row;
			this.col = col;
		}
	}

	static void findingAllPaths() {
        Queue<Problem2Cell> cellQueue = new LinkedList<Problem2Cell>();
        cellQueue.add(startCell);

        do {
        	Problem2Cell currentCell = cellQueue.remove();
            
            if (currentCell.getRow() + 1 < matrix.length) {
                if (matrix[currentCell.getRow() + 1][currentCell.getCol()] == 'O') {
                    cellQueue.add(new Problem2Cell(currentCell.getRow() + 1, currentCell.getCol()));
                    matrix[currentCell.getRow() + 1][currentCell.getCol()] = 'a';
                }
            }
            
            if (currentCell.getRow() - 1 >= 0) {
                if (matrix[currentCell.getRow() - 1][currentCell.getCol()] == 'O') {
                    cellQueue.add(new Problem2Cell(currentCell.getRow() - 1, currentCell.getCol()));
                    matrix[currentCell.getRow() - 1][currentCell.getCol()] = 'a';
                }
            }
            
            if (currentCell.getCol() + 1 < matrix.length) {
                if (matrix[currentCell.getRow()][currentCell.getCol() + 1] == 'O') {
                    cellQueue.add(new Problem2Cell(currentCell.getRow(), currentCell.getCol() + 1));
                    matrix[currentCell.getRow()][currentCell.getCol() + 1] = 'a';
                }
            }
            
            if (currentCell.getCol() - 1 >= 0) {
                if(matrix[currentCell.getRow()][currentCell.getCol()-1] == 'O') {
                    cellQueue.add(new Problem2Cell(currentCell.getRow(), currentCell.getCol() - 1));
                    matrix[currentCell.getRow()][currentCell.getCol() - 1] = 'a';
                }
            }
        } while (cellQueue.size() != 0);
    }

	static int FindExits() {
        int counterExits = 0;
        for (int i = 0; i < 1; i++) {
            for (int j = 0; i < matrix.GetLength(0); i++)
            {
                if (matrix[i, j] == 'a')
                {                     
                    counterExits++;
                    if (i == j) continue;
                }
                if (matrix[j, i] == 'a')
                {
                    counterExits++;
                }
            }
        }

        for (int i = matrix.GetLength(0) - 1; i > matrix.GetLength(0) - 2; i--)
        {
            for (int j = matrix.GetLength(0) - 1; i > 0; i--)
            {
                if (matrix[i, j] == 'a')
                {
                    counterExits++;
                    if (i == j) continue;
                }
                if (matrix[j, i] == 'a')
                {
                    counterExits++;
                }
            }
        }
        return counterExits;
    }

	public static void main(String[] args) {
		
        Scanner reader = new Scanner(new File("/Tests1/test.001.in.txt"), "windows-1251");
        int n = Integer.parseInt(reader.nextLine());
        matrix = new char[n][n];

        for (int i = 0; i < n; i++) {
            String line = reader.nextLine();
            for (int j = 0; j < n; j++) {
                matrix[i][j] = line.charAt(j);
                if (line.charAt(j) == '*') {
                    startCell = new Cell(i, j);
                }
            }
        }
        reader.close();

        Problem2LabirintAllPaths labirint = new Problem2LabirintAllPaths();
        findingAllPaths();
        int numberOfExits = FindExits();

        StreamWriter writer = new StreamWriter(
            "../../Files/test.001.out.txt");
        using (writer)
        {
            writer.WriteLine(numberOfExits);
        }
    }
}
